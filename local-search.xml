<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>对类const成员函数的理解</title>
    <link href="/cannie-luo.guthub.io/2024/06/24/%E5%AF%B9%E7%B1%BBconst%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/cannie-luo.guthub.io/2024/06/24/%E5%AF%B9%E7%B1%BBconst%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>const的作用很总是显的很让人迷惑，尤其类的const成员函数。实际它是跟this指针和顶层const底层const息息相关。</p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>说到类的常量成员函数就不得不提this指针，this表示指向当前调用函数对象的指针，在C++中的准确定义是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>是一个额外隐式参数，用来访问当前对象，而它的本质是一个常量指针即 T * <span class="hljs-keyword">const</span> <span class="hljs-keyword">this</span>. <br></code></pre></td></tr></table></figure><p>常量指针与指向常量的指针之间的区别是，前者是指针不可变，后者是指向的内容不可变，即this指针指向当前对象后，就不能用this去指向别的对象，因此它是一个常量指针。</p><h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><p>const成员函数是指在类中声明一个函数时形参列表后跟着const，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>  cout &lt;&lt; i &lt;&lt; endl;<br>  &#125; <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Foo foo;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>    foo.<span class="hljs-built_in">hello</span>(a);  <span class="hljs-comment">// 等价于 foo.hello(&amp;foo, a);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述的代码可以看出，相当于有一个对象地址隐式传参，那么在声明这个函数的角度看，函数的形式应该是这样子的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br><span class="hljs-keyword">public</span>: <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(Foo* <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>        cout &lt;&lt; i &lt;&lt; endl;<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>而当我们将成员函数声明成const时，函数形式将变成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br><span class="hljs-keyword">public</span>: <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-type">const</span> Foo* <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>, <span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; i &lt;&lt; endl;<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>因为this是const类型，那么就防止了成员函数对类中的成员进行了修改。</p><h2 id="const成员函数的调用"><a href="#const成员函数的调用" class="headerlink" title="const成员函数的调用"></a>const成员函数的调用</h2><p>前面我们已经了解过顶层const和底层const，那么就可以理解下面调用是否合法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  A a1, <span class="hljs-type">const</span> a2;<br>  a1.<span class="hljs-built_in">func1</span>();  <span class="hljs-comment">// ok: a1.func1(&amp;a1)</span><br>  a1.<span class="hljs-built_in">func2</span>();  <span class="hljs-comment">// ok: a1.func1(&amp;a1)</span><br>  <br>  a2.<span class="hljs-built_in">func1</span>();  <span class="hljs-comment">// ok: a2.func2(&amp;a2)</span><br>  a2.<span class="hljs-built_in">func2</span>();  <span class="hljs-comment">// error: 根据顶层const和底层const，const A 不能转成 A类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>了解完调用的原理后，是不是就完全可以理解透了类的const成员函数？</p>]]></content>
    
    
    <categories>
      
      <category>C++学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量和类型</title>
    <link href="/cannie-luo.guthub.io/2024/06/23/%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B/"/>
    <url>/cannie-luo.guthub.io/2024/06/23/%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>在C++中，声明一个变量的格式是<font color='red'>类型 变量名</font>，其中变量之间逗号分隔，以分号为结束。C++语言定义了几种基本类型：字符型、整型、浮点型、布尔型、void等，除此之外还提供了可用于<strong>自定义数据类型</strong>的机制，标准库利用这一机制定义更多复杂的类型，比如可变长度的string、vector等类型。开发者还可以根据修改组合的方式形成复合类型。</p><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><h3 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h3><p>C++定义了字符类型、整型、浮点型、布尔型以及void的特殊类型<br>算术类型的存储空间根据机器而定。存储空间中最小单位<font color='red'>位(bit)数</font>。</p><table><thead><tr><th align="left">类型名</th><th align="left">含义</th><th align="left">字节数</th><th align="left">取值范围</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">整型，表示整数</td><td align="left">4</td><td align="left">-2^31 ~ 2^31 -1</td></tr><tr><td align="left">long</td><td align="left">长整型，表示整数</td><td align="left">4</td><td align="left">-2^31 ~ 2^31 -1</td></tr><tr><td align="left">short</td><td align="left">短整型，表示整数</td><td align="left">2</td><td align="left">-2^15 ~ 2^15 -1</td></tr><tr><td align="left">unsigned int</td><td align="left">无符号整型，表示非负数</td><td align="left">4</td><td align="left">0 ~ 2^32 -1</td></tr><tr><td align="left">unsigned short</td><td align="left">无符号短整型、表示非负整数</td><td align="left">2</td><td align="left">0 ～2^16 -1</td></tr><tr><td align="left">unsigned long</td><td align="left">无符号长整型、表示非负整数</td><td align="left">4</td><td align="left">0 ～2^32 -1</td></tr><tr><td align="left">long long</td><td align="left">64位整型，表示整数</td><td align="left">8</td><td align="left">-2^63 ~ 2^63 -1</td></tr><tr><td align="left">unsigned long long</td><td align="left">64位无符号整型、表示非负整数</td><td align="left">8</td><td align="left">0 ~ 2^63 -1</td></tr><tr><td align="left">float</td><td align="left">单精度实数型，表示实数</td><td align="left">4</td><td align="left">3.4 * 10^-38 ~  3.4 * 10^38</td></tr><tr><td align="left">double</td><td align="left">双精度实数型，表示实数</td><td align="left">8</td><td align="left">1.7 * 10^-308  ~  1.7 * 10^308</td></tr><tr><td align="left">char</td><td align="left">字符型，表示字符</td><td align="left">1</td><td align="left">-128 ～ 127</td></tr><tr><td align="left">unsigned char</td><td align="left">无符号字符型，表示字符</td><td align="left">1</td><td align="left">0 ～ 255</td></tr><tr><td align="left">bool</td><td align="left">布尔类型，表示真假</td><td align="left">1</td><td align="left">true 或者 false</td></tr></tbody></table><blockquote><ul><li>整型、字符型、布尔型合称为整型;</li><li>字符型有两种：char和wchar_t。char类型通常是单个机器字节（byte)，可以存放机器基本字符集中任意字符对应的数值。而wchar_t可以存放机器最大扩展字符集中的任意一个字符;</li><li>bool类型的取值是真值true或者假值false。0值算术类型表示false，任何非0都代表true；</li><li>short、int、long、char都默认有符号类型，若要使用无符号需要在前加unsigned修饰，表示无符号；</li><li>浮点型可表示<strong>单精度、双精度和扩展精度值</strong>，分别对应float、double、long double类型。</li></ul></blockquote><h3 id="内置类型之间的转换"><a href="#内置类型之间的转换" class="headerlink" title="内置类型之间的转换"></a>内置类型之间的转换</h3><p>进行类型转换时，类型所能表示的值的范围决定了转换的过程。</p><blockquote><ul><li>把非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true;</li><li>把布尔值赋给非布尔类型时，初始值为 false 则结果为0，初始值为 true 则结果为1;</li><li>把浮点数赋给整数类型时，进行近似处理，结果值仅保留浮点数中的整数部分;</li><li>把整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失;</li><li>赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数（8比特大小的 unsigned char 能表示的数值总数是256）取模后的余数;</li><li>赋给带符号类型一个超出它表示范围的值时，结果是未定义的<strong>（undefined)</strong>。</li></ul></blockquote><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>整数的表现形式：</p><table><thead><tr><th align="left">进制类型</th><th align="left">表现形式</th></tr></thead><tbody><tr><td align="left">二进制</td><td align="left">0b或者0B开头</td></tr><tr><td align="left">八进制</td><td align="left">0开头</td></tr><tr><td align="left">十六进制</td><td align="left">0x或者0X开头</td></tr></tbody></table><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>变量定义的基本形式：<strong>类型说明符（type specifier）</strong>后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">下列语句定义了<span class="hljs-number">5</span>个变量：<br><span class="hljs-type">int</span> units_sold;<br><span class="hljs-type">double</span> sales_price, avg_price;<br>std::string title;<br>Sales_item curr_book;<br></code></pre></td></tr></table></figure><p>每个定义都是以类型说明符开始，后面紧跟着以逗号分开的含有一个或者多个说明符的列表，分号结束定义。类型说明符指定与对象相关联的类型：int、double、std::string和Sales_item都是类型名。<br>其中int和double时内置类型，std::string是标准库定义的类型，Sales_item是类中使用的类型。类型决定了分配给变量存储空间的的大小和可以在其上执行的操作。<br>多个变量可以定义在同一条语句中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">double</span> salary, wage; <span class="hljs-comment">// 定义两个 double 类型的变量</span><br><span class="hljs-type">int</span> month, day, year; <span class="hljs-comment">// 定义三个 int 类型的变量</span><br>std::string address; <span class="hljs-comment">// 定义一个 std::string 的变量</span><br></code></pre></td></tr></table></figure><p>定义时可以为一个或多个变量赋初始值，即初始化，初始化不等于赋值。<br><strong>Note:</strong> 初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，再用一个新值来替代。<br>用花括号初始化变量称为<strong>列表初始化</strong>。当用于内置类型的变量时，编译器会检查类型是否安全，都精度存在丢失的风险，编译器会报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">long</span> <span class="hljs-type">double</span> ld = <span class="hljs-number">3.1415926536</span>;<br><span class="hljs-type">int</span> a&#123;ld&#125;, b = &#123;ld&#125;;    <span class="hljs-comment">// error: 转换未执行，因为存在丢失信息的危险</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c</span><span class="hljs-params">(ld)</span>, d </span>= ld;      <span class="hljs-comment">// ok: 转换执行，且确实丢失了部分值</span><br></code></pre></td></tr></table></figure><p>若定义变量时未指定初值，则变量会被默认初始化。对于内置类型，定义于任何函数体之外的变量被初始化为0，函数体内部的变量将不被初始化。定义在函数体内的内置类型对象如果没有初始化，则其值未定义，使用该类型时一种错误的编程行为而且很难调试。如果类的对象没有显示初始化，则其值由类确定。<font color ='red'> 建议初始化每一个内置类型的变量</font>。</p><h3 id="变量的声明和定义的关系"><a href="#变量的声明和定义的关系" class="headerlink" title="变量的声明和定义的关系"></a>变量的声明和定义的关系</h3><blockquote><ul><li><strong>声明(declaration)</strong>使得名字为程序所知。一个文件如果想要使用其他地方定义的名字，则必须先包含对那个名字的声明。</li><li><strong>定义(defination)</strong>负责创建与名字相关联的实体即分配一个具体地址来存储内容。<br>如果想声明一个变量但是不定义它时，可以在变量名前添加关键字extern，并且不要显式地初始化变量。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i; <span class="hljs-comment">// 声明但不定义 i</span><br><span class="hljs-type">int</span> j;      <span class="hljs-comment">// 声明并定义 j</span><br></code></pre></td></tr></table></figure><p>extern语句中如果包含了初始化值就不再是声明了，而变成了定义。变量能且只能被定义一次，但可以被声明多次。<br>如果要在多个文件中使用同一个变量，就必须将声明和定义分开。此时变量的定义必须且只能出现在一个文件中，其他使用该变量的文件必须对其进行声明，但绝对不能重复定义。</p><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><blockquote><ul><li>变量命名由许多约定俗成的规定以此来提高程序的可读性：</li><li>C++ 的变量名，即标识符，由字母、数字和下划线组成，其中必须以字母或下划线开头；</li><li>变量名一般用小写字母；</li><li>用户自定义的类名一般以大写字母开头；</li><li>标识符的长度没有限制，但是对大小写字母敏感。</li></ul></blockquote><h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>那些定义在非某个作用域、函数体、类内的变量称为<strong>全局变量(global scope)</strong>，声明之后，该名字在整个程序范围内都可使用。最好在第一次使用变量时再去定义它。这样做更容易找到变量的定义位置，并且也可以赋给它一个比较合理的初始值。<br>作用域中一旦声明了某个名字，在它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字，此时内层作用域中新定义的名字将屏蔽外层作用域的名字。<br>可以用作用域操作符<font color = 'red'> :: </font> 来覆盖默认的作用域规则。因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，会向全局作用域发出请求获取作用域操作符右侧名字对应的变量</p>]]></content>
    
    
    <categories>
      
      <category>C++学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解顶层const和底层const</title>
    <link href="/cannie-luo.guthub.io/2024/06/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const/"/>
    <url>/cannie-luo.guthub.io/2024/06/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const/</url>
    
    <content type="html"><![CDATA[<h2 id="如何理解顶层const和底层const"><a href="#如何理解顶层const和底层const" class="headerlink" title="如何理解顶层const和底层const"></a>如何理解顶层const和底层const</h2><p>《C++ primer》中写到：</p><blockquote><ul><li>顶层const表示指针本身是一个常量</li><li>底层const表示指针所指的对象是一个常量<br>指针类型既可以是顶层const又可以是底层const。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p1 = &amp;i;        <span class="hljs-comment">// 不能改变p1的值，这是一个顶层const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">2</span>;   <span class="hljs-comment">// 不能改变ci的值，这是一个顶层const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p2 = &amp;ci;       <span class="hljs-comment">// 可以改变p2的值，这是一个底层const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3 = p2;  <span class="hljs-comment">// 靠右的const是顶层const，靠左的const是底层const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ri = ci;        <span class="hljs-comment">// 用于声明引用的const都是底层const</span><br></code></pre></td></tr></table></figure><p>即（除了const int ci &#x3D; 2; &#x2F;&#x2F;是顶层const): </p><blockquote><ul><li>如果const右结合修饰为类型或者*，那这个const就是一个底层const:</li><li>如果const右结合修饰为标识符，那这个const就是一个顶层const;</li></ul></blockquote><p>是不是感觉很绕口，个人的理解是</p><blockquote><ul><li>被修饰的变量本身无法改变的const是顶层const；</li><li>通过指针或者引用等间接途径来限制目标内容不可改变的const是底层const;</li></ul></blockquote><p>实际就是取决const修饰的是谁，从右往左看const是修饰谁决定</p><h2 id="顶层const和底层const的区别"><a href="#顶层const和底层const的区别" class="headerlink" title="顶层const和底层const的区别"></a>顶层const和底层const的区别</h2><p>当执行拷贝操作时，常量是顶层const还是底层const的区别就非常明显：</p><blockquote><ul><li>顶层const没有影响。拷贝操作不会改变被拷贝对象的值，因此拷入和拷出的对象是否是常量无关紧要。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">i = ci;    <span class="hljs-comment">//ok: 拷贝ci的值，ci是一个顶层const，对此操作没有影响</span><br>p2 = p3;   <span class="hljs-comment">//ok: p2和p3指向的对象类型相同，p3顶层const部分不影响</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>底层const的限制不能忽视。拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型可以相互转换（一般来说，<font color='red'>被拷贝对象</font>从非const可以转换成const类型，反之则不行）</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *p = p3;       <span class="hljs-comment">//error: p3包含了底层const的定义，而p没有</span><br>p2 = p3;           <span class="hljs-comment">//ok: p2和p3都是底层的const</span><br>p2 = &amp;i;           <span class="hljs-comment">//ok: 非常量的int* 可以转换成const int*</span><br><span class="hljs-type">int</span> &amp;r = ci;       <span class="hljs-comment">//error: 普通的int&amp;不能绑定到int常量上</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = i; <span class="hljs-comment">//ok: const int&amp;可以绑定到一个普通的int上(在开发的过程最常见到函数传参方式）</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/cannie-luo.guthub.io/2024/06/22/%E5%87%BD%E6%95%B0/"/>
    <url>/cannie-luo.guthub.io/2024/06/22/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github创建个人博客</title>
    <link href="/cannie-luo.guthub.io/2024/06/21/hexo+github%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/cannie-luo.guthub.io/2024/06/21/hexo+github%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>终于把自己的个人博客给搭建起来了，感谢<a href="https://blog.csdn.net/yaorongke/article/details/119089190">yaorongke</a>，写的很详细，虽然中间有些小挫折碰到了一些小问题，好在都解决了。搭建的详细步骤请参考yaorongke的文章，此处仅记录一下碰到的问题。</p><h2 id="GitHub认证问题"><a href="#GitHub认证问题" class="headerlink" title="GitHub认证问题"></a>GitHub认证问题</h2><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p>出现下面这种报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">nothing to commit, working tree clean  <br>Username <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;https://github.com&#x27;</span>: cannie-luo<br>Password <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;https://cannie-luo@github.com&#x27;</span>:    <br>remote: Permission to cannie-luo/cannie-luo.guthub.io.git denied to cannie-luo.   <br>fatal: unable to access <span class="hljs-string">&#x27;https://github.com/cannie-luo/cannie-luo.guthub.io.git/&#x27;</span>: The requested URL returned error: 403  <br></code></pre></td></tr></table></figure><p>出现这种问题大概是因为密码的问题，GitHub已经不支持密码验证身份，需要将密码替换成生成的token。</p><h3 id="代理问题"><a href="#代理问题" class="headerlink" title="代理问题"></a>代理问题</h3><p>hexo g -d 提交时发生下面的错误提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">fatal: unable to access <span class="hljs-string">&#x27;https://github.com/XXX/XXX.github.io.git/&#x27;</span>: Failed to connect to github.com port 443: Timed out<br>FATAL Something<span class="hljs-string">&#x27;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="hljs-string">Error: Spawn failed......</span><br></code></pre></td></tr></table></figure><p>这是因为代理的问题，需要unset一下http、https的代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy`<br></code></pre></td></tr></table></figure><h2 id="hexo推送到GitHub后，页面样式错乱不显示"><a href="#hexo推送到GitHub后，页面样式错乱不显示" class="headerlink" title="hexo推送到GitHub后，页面样式错乱不显示"></a>hexo推送到GitHub后，页面样式错乱不显示</h2><p>将静态文件推送到GitHub后，开心的飞起，但是一打开就是页面不完整，点开链接就是404，emmm找了半天的问题，其实很简单就是_config.yml文件中URL没配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Set your site url here. For example, <span class="hljs-keyword">if</span> you use GitHub Page, <span class="hljs-built_in">set</span> url as <span class="hljs-string">&#x27;https://username.github.io/project&#x27;</span><br>url: https://cannie-luo.github.io/cannie-luo.guthub.io/<br>permalink: :year/:month/:day/:title/<br>permalink_defaults:<br></code></pre></td></tr></table></figure><p>需要将你个人博客的仓库地址填写到url中，重新推送到GitHub中，清除一下缓存，重新打开页面。</p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
